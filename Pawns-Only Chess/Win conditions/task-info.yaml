type: edu
files:
- name: src/chess/Main.kt
  visible: true
  text: |-
    package chess

    fun main() {
    //    write your code here
    }
  learner_created: false
- name: test/PawnsOnlyChessTest.kt
  visible: false
  text: |+
    import org.hyperskill.hstest.dynamic.DynamicTest
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testing.TestedProgram

    class PawnsOnlyChessTest : StageTest<Any>() {
        @DynamicTest
        fun testAdd5(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) { index -> Pair(1, index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) { index -> Pair(6, index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            for (ch in 'a'..'h') {
                outputString = main.execute("${ch}2${ch}4").trim()
                pawnsWhite.remove(Pair(1, ch - 'h' + 7))
                pawnsWhite.add(Pair(3, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "amelia's turn:")
                if (position == -1) return CheckResult(false, "Player 2 prompt to play is expected.")

                outputString = main.execute("${ch}7${ch}5").trim()
                pawnsBlack.remove(Pair(6, ch - 'h' + 7))
                pawnsBlack.add(Pair(4, ch - 'h' + 7))
                position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
                if (position == -1) return CheckResult(false, "Wrong chessboard printout after 2 squares move.")
                position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
                if (position == -1) return CheckResult(false, "Player 1 prompt to play is expected.")
            }

            outputString = main.execute("exit").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "bye")
            if ( position  == -1 ) return CheckResult(false, "Exit message is expected.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test1(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2e4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(3, 4))
            outputString = main.execute("d7d5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 3))
            pawnsBlack.add(Pair(4, 3))
            outputString = main.execute("e4d5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 3))
            pawnsWhite.remove(Pair(3, 4))
            pawnsWhite.add(Pair(4, 3))
            outputString = main.execute("c7c6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 2))
            pawnsBlack.add(Pair(5, 2))
            outputString = main.execute("d5d6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(4, 3))
            pawnsWhite.add(Pair(5, 3))
            outputString = main.execute("c6c5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 2))
            pawnsBlack.add(Pair(4, 2))
            outputString = main.execute("d6d7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(5, 3))
            pawnsWhite.add(Pair(6, 3))
            outputString = main.execute("c5c4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 2))
            pawnsBlack.add(Pair(3, 2))
            outputString = main.execute("d7d8").trim()
            pawnsWhite.remove(Pair(6, 3))
            pawnsWhite.add(Pair(7, 3))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after white pawn reaches 8th rank.")
            position = checkOutput(outputString.toLowerCase(), position, "white wins!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after white pawn reaches 8th rank.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test2(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("e2e4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(3, 4))
            outputString = main.execute("d7d5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 3))
            pawnsBlack.add(Pair(4, 3))
            outputString = main.execute("b2b3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 1))
            pawnsWhite.add(Pair(2, 1))
            outputString = main.execute("d5e4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 4))
            pawnsBlack.remove(Pair(4, 3))
            pawnsBlack.add(Pair(3, 4))
            outputString = main.execute("b3b4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(2, 1))
            pawnsWhite.add(Pair(3, 1))
            outputString = main.execute("e4e3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(3, 4))
            pawnsBlack.add(Pair(2, 4))
            outputString = main.execute("b4b5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 1))
            pawnsWhite.add(Pair(4, 1))
            outputString = main.execute("e3e2").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(2, 4))
            pawnsBlack.add(Pair(1, 4))
            outputString = main.execute("b5b6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(4, 1))
            pawnsWhite.add(Pair(5, 1))
            outputString = main.execute("e2e1").trim()
            pawnsBlack.remove(Pair(1, 4))
            pawnsBlack.add(Pair(0, 4))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after black pawn reaches 1st rank.")
            position = checkOutput(outputString.toLowerCase(), position, "black wins!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after black pawn reaches 1st rank.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test3(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("a2a4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 0))
            pawnsWhite.add(Pair(3, 0))
            outputString = main.execute("b7b5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 1))
            pawnsBlack.add(Pair(4, 1))
            outputString = main.execute("a4b5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 1))
            pawnsWhite.remove(Pair(3, 0))
            pawnsWhite.add(Pair(4, 1))
            outputString = main.execute("c7c6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 2))
            pawnsBlack.add(Pair(5, 2))
            outputString = main.execute("b5c6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 2))
            pawnsWhite.remove(Pair(4, 1))
            pawnsWhite.add(Pair(5, 2))
            outputString = main.execute("a7a5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 0))
            pawnsBlack.add(Pair(4, 0))
            outputString = main.execute("c6d7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 3))
            pawnsWhite.remove(Pair(5, 2))
            pawnsWhite.add(Pair(6, 3))
            outputString = main.execute("a5a4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 0))
            pawnsBlack.add(Pair(3, 0))
            outputString = main.execute("d2d4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 3))
            pawnsWhite.add(Pair(3, 3))
            outputString = main.execute("e7e5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 4))
            pawnsBlack.add(Pair(4, 4))
            outputString = main.execute("d4e5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 4))
            pawnsWhite.remove(Pair(3, 3))
            pawnsWhite.add(Pair(4, 4))
            outputString = main.execute("f7f6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 5))
            pawnsBlack.add(Pair(5, 5))
            outputString = main.execute("e5f6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 5))
            pawnsWhite.remove(Pair(4, 4))
            pawnsWhite.add(Pair(5, 5))
            outputString = main.execute("h7h5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 7))
            pawnsBlack.add(Pair(4, 7))
            outputString = main.execute("f6g7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 6))
            pawnsWhite.remove(Pair(5, 5))
            pawnsWhite.add(Pair(6, 6))
            outputString = main.execute("a4a3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(3, 0))
            pawnsBlack.add(Pair(2, 0))
            outputString = main.execute("b2a3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(2, 0))
            pawnsWhite.remove(Pair(1, 1))
            pawnsWhite.add(Pair(2, 0))
            outputString = main.execute("h5h4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 7))
            pawnsBlack.add(Pair(3, 7))
            outputString = main.execute("c2c3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 2))
            pawnsWhite.add(Pair(2, 2))
            outputString = main.execute("h4h3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(3, 7))
            pawnsBlack.add(Pair(2, 7))
            outputString = main.execute("g2h3").trim()
            pawnsBlack.remove(Pair(2, 7))
            pawnsWhite.remove(Pair(1, 6))
            pawnsWhite.add(Pair(2, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after white captures all black pawns.")
            position = checkOutput(outputString.toLowerCase(), position, "white wins!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after white wins after capturing all black pawns.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test4(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("a2a4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 0))
            pawnsWhite.add(Pair(3, 0))
            outputString = main.execute("b7b5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 1))
            pawnsBlack.add(Pair(4, 1))
            outputString = main.execute("h2h3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 7))
            pawnsWhite.add(Pair(2, 7))
            outputString = main.execute("b5a4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 0))
            pawnsBlack.remove(Pair(4, 1))
            pawnsBlack.add(Pair(3, 0))
            outputString = main.execute("b2b3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 1))
            pawnsWhite.add(Pair(2, 1))
            outputString = main.execute("a4b3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(2, 1))
            pawnsBlack.remove(Pair(3, 0))
            pawnsBlack.add(Pair(2, 1))
            outputString = main.execute("h3h4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(2, 7))
            pawnsWhite.add(Pair(3, 7))
            outputString = main.execute("b3c2").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 2))
            pawnsBlack.remove(Pair(2, 1))
            pawnsBlack.add(Pair(1, 2))
            outputString = main.execute("h4h5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 7))
            pawnsWhite.add(Pair(4, 7))
            outputString = main.execute("c7c5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 2))
            pawnsBlack.add(Pair(4, 2))
            outputString = main.execute("d2d4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 3))
            pawnsWhite.add(Pair(3, 3))
            outputString = main.execute("c5d4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 3))
            pawnsBlack.remove(Pair(4, 2))
            pawnsBlack.add(Pair(3, 3))
            outputString = main.execute("e2e3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 4))
            pawnsWhite.add(Pair(2, 4))
            outputString = main.execute("d4e3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(2, 4))
            pawnsBlack.remove(Pair(3, 3))
            pawnsBlack.add(Pair(2, 4))
            outputString = main.execute("g2g4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 6))
            pawnsWhite.add(Pair(3, 6))
            outputString = main.execute("e3f2").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 5))
            pawnsBlack.remove(Pair(2, 4))
            pawnsBlack.add(Pair(1, 5))
            outputString = main.execute("h5h6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(4, 7))
            pawnsWhite.add(Pair(5, 7))
            outputString = main.execute("g7h6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsWhite.remove(Pair(5, 7))
            pawnsBlack.remove(Pair(6, 6))
            pawnsBlack.add(Pair(5, 7))
            outputString = main.execute("g4g5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(3, 6))
            pawnsWhite.add(Pair(4, 6))
            outputString = main.execute("h6g5").trim()
            pawnsWhite.remove(Pair(4, 6))
            pawnsBlack.remove(Pair(5, 7))
            pawnsBlack.add(Pair(4, 6))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after black captures all white pawns.")
            position = checkOutput(outputString.toLowerCase(), position, "black wins!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after black wins after capturing all white pawns.")

            return CheckResult.correct()
        }

        @DynamicTest
        fun test5(): CheckResult {
            val pawnsWhite = MutableList<Pair<Int, Int>>(8) {index -> Pair(1,index) }
            val pawnsBlack = MutableList<Pair<Int, Int>>(8) {index -> Pair(6,index) }

            val main = TestedProgram()
            var outputString = main.start().trim()

            var position = checkOutput(outputString.toLowerCase(), 0, "pawns-only chess")
            if ( position  == -1 ) return CheckResult(false, "Program title is expected.")
            position = checkOutput(outputString.toLowerCase(), position, "first player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 name prompt is expected.")

            outputString = main.execute("John").trim()
            position = checkOutput(outputString.toLowerCase(), 0, "second player's name:")
            if ( position  == -1 ) return CheckResult(false, "Player 2 name prompt is expected.")

            outputString = main.execute("Amelia").trim()
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong initial chessboard printout.")
            position = checkOutput(outputString.toLowerCase(), position, "john's turn:")
            if ( position  == -1 ) return CheckResult(false, "Player 1 prompt to play is expected.")

            outputString = main.execute("a2a4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 0))
            pawnsWhite.add(Pair(3, 0))
            outputString = main.execute("b7b5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 1))
            pawnsBlack.add(Pair(4, 1))
            outputString = main.execute("a4b5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 1))
            pawnsWhite.remove(Pair(3, 0))
            pawnsWhite.add(Pair(4, 1))
            outputString = main.execute("c7c6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 2))
            pawnsBlack.add(Pair(5, 2))
            outputString = main.execute("b5c6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 2))
            pawnsWhite.remove(Pair(4, 1))
            pawnsWhite.add(Pair(5, 2))
            outputString = main.execute("a7a5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 0))
            pawnsBlack.add(Pair(4, 0))
            outputString = main.execute("c6d7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 3))
            pawnsWhite.remove(Pair(5, 2))
            pawnsWhite.add(Pair(6, 3))
            outputString = main.execute("a5a4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 0))
            pawnsBlack.add(Pair(3, 0))
            outputString = main.execute("d2d4").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsWhite.remove(Pair(1, 3))
            pawnsWhite.add(Pair(3, 3))
            outputString = main.execute("e7e5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 4))
            pawnsBlack.add(Pair(4, 4))
            outputString = main.execute("d4e5").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 4))
            pawnsWhite.remove(Pair(3, 3))
            pawnsWhite.add(Pair(4, 4))
            outputString = main.execute("f7f6").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 5))
            pawnsBlack.add(Pair(5, 5))
            outputString = main.execute("e5f6").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(5, 5))
            pawnsWhite.remove(Pair(4, 4))
            pawnsWhite.add(Pair(5, 5))
            outputString = main.execute("h7h5").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 7))
            pawnsBlack.add(Pair(4, 7))
            outputString = main.execute("f6g7").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(6, 6))
            pawnsWhite.remove(Pair(5, 5))
            pawnsWhite.add(Pair(6, 6))
            outputString = main.execute("a4a3").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(3, 0))
            pawnsBlack.add(Pair(2, 0))
            outputString = main.execute("b2a3").toLowerCase().trim()
            if ( !outputString.contains("amelia's turn:") ) return CheckResult(false, "Player 2 prompt to play is expected.")
            pawnsBlack.remove(Pair(2, 0))
            pawnsWhite.remove(Pair(1, 1))
            pawnsWhite.add(Pair(2, 0))
            outputString = main.execute("h5h4").toLowerCase().trim()
            if ( !outputString.contains("john's turn:") ) return CheckResult(false, "Player 1 prompt to play is expected.")
            pawnsBlack.remove(Pair(4, 7))
            pawnsBlack.add(Pair(3, 7))
            outputString = main.execute("h2h3").trim()
            pawnsWhite.remove(Pair(1, 7))
            pawnsWhite.add(Pair(2, 7))
            position = checkChessboard(outputString, 0, pawnsWhite, pawnsBlack)
            if ( position  == -1 ) return CheckResult(false, "Wrong chessboard printout after white captures all black pawns.")
            position = checkOutput(outputString.toLowerCase(), position, "stalemate!", "bye")
            if ( position  == -1 ) return CheckResult(false, "Wrong output after white wins after stalemate.")

            return CheckResult.correct()
        }

    }

    fun checkChessboard(outputString: String, searchPos: Int, pawnsWhite: List<Pair<Int, Int>>, pawnsBlack: List<Pair<Int, Int>>): Int {
        fun createChessboardStringList(pawnsWhite: List<Pair<Int, Int>>, pawnsBlack: List<Pair<Int, Int>>): List<String> {
            var chessboard = "  +---+---+---+---+---+---+---+---+\n"
            for (i in 7 downTo 0) {
                chessboard += "${i + 1} |"
                for (j in 0..7) {
                    val square = when {
                        pawnsWhite.contains(Pair(i, j)) -> 'W'
                        pawnsBlack.contains(Pair(i, j)) -> 'B'
                        else -> ' '
                    }
                    chessboard += " $square |"
                }
                chessboard += "\n  +---+---+---+---+---+---+---+---+\n"
            }
            chessboard += "    a   b   c   d   e   f   g   h\n"
    //        println(chessboard)
            return chessboard.trim().split("\n").map { it.trim() }
        }
        val chessboardStringList = createChessboardStringList(pawnsWhite, pawnsBlack)
        return checkOutput(outputString, searchPos, * chessboardStringList.toTypedArray())
    }

    fun checkOutput(outputString: String, searchPos: Int, vararg checkStr: String): Int {
        var searchPosition = searchPos
        for (str in checkStr) {
            val findPosition = outputString.indexOf(str, searchPosition)
            if (findPosition == -1) return -1
            if ( outputString.substring(searchPosition until findPosition).isNotBlank() ) return -1
            searchPosition = findPosition + str.length
        }
        return searchPosition
    }


  learner_created: false
- name: src/chess/Pawn.kt
  visible: true
  text: |
    package chess

    data class Pawn(val player: Player) {
        var hasMoved = false

        fun setMoved() {
            hasMoved = true
        }

        fun belongsTo(player: Player): Boolean {
            return player === this.player
        }
    }
  learner_created: true
- name: src/chess/IllegalMoveException.kt
  visible: true
  text: |
    package chess

    class IllegalMoveException : IllegalArgumentException() {
    }
  learner_created: true
- name: src/chess/GameBoard.kt
  visible: true
  text: |
    package chess

    import java.util.*
    import kotlin.math.abs

    class GameBoard {

        val cells = buildList {
            for (i in 0 until 8) {
                add(buildList {
                    for (j in 0 until 8) {
                        add(Cell(i, j))
                    }
                })
            }
        }

        fun putPawns(player: Player) {
            val row = if (player.isFirst) 1 else 6
            for (j in 0 until 8) {
                val pawn = player.pawns[j]
                val cell = cells[row][j]
                cell.putPawn(pawn)
            }
        }

        fun checkAndMovePawn(player: Player, fromCell: Cell, toCell: Cell) {
            val moveType = checkMove(player, fromCell, toCell)
            val pawn = fromCell.pawn.get()
            movePawn(pawn, fromCell, toCell)
            if (moveType == MoveType.DOUBLE) {
                if (player.isFirst) {
                    cells[fromCell.row + 1][fromCell.col].capturePawn = Optional.of(toCell)
                } else {
                    cells[fromCell.row - 1][fromCell.col].capturePawn = Optional.of(toCell)
                }
            } else if (moveType == MoveType.CAPTURE && toCell.capturePawn.isPresent) {
                captureAtCell(player, toCell.capturePawn.get())
            } else {
                //Nothing special
            }
        }

        private fun checkMove(player: Player, fromCell: Cell, toCell: Cell): MoveType {
            if (fromCell.pawn.isEmpty || !fromCell.pawn.get().belongsTo(player)) {
                throw IllegalPieceException()
            }
            val moveType = determineMoveType(player, fromCell, toCell)
            if (moveType != MoveType.CAPTURE && toCell.pawn.isPresent) {
                throw IllegalMoveException()
            }
            val pawn = fromCell.pawn.get()
            if (moveType == MoveType.DOUBLE && pawn.hasMoved) {
                throw IllegalMoveException()
            }
            if (moveType == MoveType.CAPTURE && toCell.pawn.isEmpty && toCell.capturePawn.isEmpty) {
                throw IllegalMoveException()
            }
            return moveType
        }

        private fun determineMoveType(player: Player, fromCell: Cell, toCell: Cell): MoveType {
            val rowDiff =
                if (player.isFirst) toCell.row - fromCell.row
                else fromCell.row - toCell.row
            if (fromCell.col == toCell.col) {
                return if (rowDiff == 1) {
                    MoveType.SINGLE
                } else if (rowDiff == 2) {
                    MoveType.DOUBLE
                } else {
                    throw IllegalMoveException()
                }
            } else if (abs(fromCell.col - toCell.col) == 1) {
                if (rowDiff == 1) {
                    return MoveType.CAPTURE
                } else {
                    throw IllegalMoveException()
                }
            } else {
                throw IllegalMoveException()
            }
        }

        private fun movePawn(pawn: Pawn, fromCell: Cell,  toCell: Cell) {
            pawn.setMoved()
            fromCell.empty()
            toCell.putPawn(pawn)
        }

        private fun captureAtCell(player: Player, cell: Cell) {
            val pawn = cell.pawn.get()
            if (player == pawn.player) {
                throw IllegalMoveException()
            }
            cell.empty()
        }

        fun printState() {
            print("  ")
            for (j in 'a'..'h') print("+---")
            println("+")
            for (i in 8 downTo 1) {
                print("$i ")

                for (j in 'a'..'h') {
                    val cell = cellFromString("$j$i")
                    val char =
                        if (cell.pawn.isEmpty) ' '
                        else cell.pawn.get().player.symbol
                    print("| $char ")
                }
                println("|")
                print("  ")
                for (j in 'a'..'h') print("+---")
                println("+")
            }
            print("  ")
            for (j in 'a'..'h') print("  $j ")
            println(" ")
        }

        private fun cellFromString(str: String): Cell {
            if (str.length != 2) throw IllegalArgumentException("Not a valid position")
            val col = cols.indexOf(str[0])
            if (col == -1) throw IllegalArgumentException("Not a valid position")
            val row = try {
                str[1].digitToInt() - 1
            } catch (e: NumberFormatException) {
                throw IllegalArgumentException("Not a valid position")
            }
            return cells[row][col]
        }

        fun moveFromString(input: String): Pair<Cell, Cell> {
            if (!input.matches(allowedMoves)) throw IllegalArgumentException()
            val from = input.substring(0..1)
            val to = input.substring(2..3)
            val fromCell = cellFromString(from)
            val toCell = cellFromString(to)
            return Pair(fromCell, toCell)
        }

        fun clearCaptureFlags(player: Player) {
            for (row in cells) {
                for (cell in row) {
                    if (cell.capturePawn.isPresent
                        && (cell.capturePawn.get().pawn.isEmpty
                        || cell.capturePawn.get().pawn.get().player == player)) {
                        cell.capturePawn = Optional.empty()
                    }
                }
            }
        }

        companion object {
            val allowedMoves = """([a-h][1-8]){2}""".toRegex()

            private const val cols = "abcdefgh"
        }

        data class Cell(val row: Int, val col: Int) {

            var capturePawn = Optional.empty<Cell>()

            var pawn = Optional.empty<Pawn>()

            fun putPawn(pawn: Pawn) {
                this.pawn = Optional.of(pawn)
            }

            fun empty() {
                this.pawn = Optional.empty()
            }

            override fun toString(): String {
                return "${cols[col]}${row + 1}"
            }

        }

        enum class MoveType {
            SINGLE,
            DOUBLE,
            CAPTURE;
        }

    }
  learner_created: true
- name: src/chess/IllegalPieceException.kt
  visible: true
  text: |
    package chess

    class IllegalPieceException : IllegalArgumentException() {
    }
  learner_created: true
- name: src/chess/Player.kt
  visible: true
  text: |
    package chess

    data class Player(val name: String, val isFirst: Boolean) {

        val symbol: Char = if (isFirst) 'W' else 'B'

        val color: String = if (isFirst) "white" else "black"

        val pawns = buildList {
            for (i in 0 until 8) {
                add(Pawn(this@Player))
            }
        }

    }
  learner_created: true
- name: src/chess/CyclicPair.kt
  visible: true
  text: |
    package chess

    /**
     * Utility class representing a pair over whose components we can iterate cyclically
     * starting on the first component of the pair
     * @param pair pair with the components that we want to iterate over
     */
    class CyclicPair<T>(private val pair: Pair<T, T>) : Iterator<T> {
        /** Constructor from the components directly */
        constructor(first: T, second: T) : this(Pair(first, second))

        /** Counter to keep track of the iterator's current element */
        private var i = 0

        /** Checks if the iterator has a next element. Always true */
        override fun hasNext(): Boolean {
            return true
        }

        /** Advances the iterator to the next position and returns its element */
        override fun next(): T {
            i++
            return current()
        }

        /** Returns the component on the current position of the iterator */
        fun current(): T {
            return if (i % 2 == 0) pair.first
            else pair.second
        }

        /** Resets the iterator to the original position */
        fun reset() {
            i = 0
        }
    }
  learner_created: true
- name: src/chess/GameController.kt
  visible: true
  text: |
    package chess

    class GameController(val player1: Player, val player2: Player, val board: GameBoard) {

        val turnDecider = CyclicPair(player1, player2)

        init {
            board.putPawns(player1)
            board.putPawns(player2)
        }
    }
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/13178#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Wed, 15 Jun 2022 22:04:03 UTC
record: -1
